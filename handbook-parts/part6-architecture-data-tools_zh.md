## 架构

有许多优秀的资源深入探讨各种架构模式；我最喜欢的资源之一是Martin Fowler的《企业应用架构模式》。在本章中，我将概述一些你会听到的关键术语，这样你在其他地方深入探讨这些主题时就有了上下文。

### 领域驱动设计

领域驱动设计（DDD）是一种专注于理解和建模问题领域以设计更好软件解决方案的软件开发方法。

DDD的核心概念包括：

**领域模型：** 将业务概念表示为技术系统中的对象；

**通用语言：** 在公司内部使用的通用、一致的词汇和语言，以减少混淆；

**限界上下文：** 领域模型适用并使用通用语言的边界。


#### 高层模式

当有人使用"技术架构"这个短语时，他们通常指的是代码如何执行以及信息如何在系统中流动。大多数架构描述都涉及服务、单体或消息传输等短语。这与编码模式形成对比，在编码模式中，面向对象、函数式编程或依赖注入等短语经常出现。编码模式有时可能被称为代码架构，将在编码模式（第188页）中讨论。

技术架构中影响最大的决策是代码是作为单体运行还是作为一组服务（通常称为微服务）运行。我将首先描述每种模式的样子，然后提供一些关于它们之间权衡的指导。

##### 单体架构

单体架构模式是所有代码作为单个进程执行的模式，其中信息完全在内存中在系统各部分之间移动，建模为简单的函数调用。如果你曾经坐下来在一个下午构建一个简单的应用程序，很可能它会属于单体类别。单体有各种形状和大小，从非常小到大规模的数百万行项目。

构建成功单体的关键是仔细设计应用程序内的数据流，使用领域驱动设计。你可以很容易地衡量这一点；你希望确保当开发人员去更改应用程序的功能时，很明显他们应该在单体的哪个位置工作。他们应该只需要在一个明显且定义良好或受限的区域中更改代码来实现他们的目标。每个需要更改以满足功能需求的代码库额外区域都会增加额外的复杂性或出错机会，并且通常会减慢开发速度。

单体的主要特征：

* 代码作为单个单元部署。
* 代码在单个源代码仓库中管理。
* 部署的代码作为单个单元上下扩展。
* 信息在内存中在系统各部分之间移动，通常通过函数调用。
* 领域驱动设计和清晰的信息流设计不是由系统强制执行的，而是留给工程师来做好设计。

##### 面向服务架构（SOA）/微服务

面向服务架构（SOA）这个短语起源于1990年代，用于指代一些相当具体的技术选择。如今，这个短语更广泛地用于描述信息通过网络在系统各部分之间移动的系统。与单体相比，SOA的主要权衡是它可能非常复杂，需要团队进行大量设置和深思熟虑的设计，才能真正确保收益超过增加的复杂性。

微服务是面向服务架构的一个子集，其中每个服务如其名称所示非常小。有些系统实现有数千个微服务，每个只有几行代码。也就是说，你不需要有数千个微服务才能体验到面向服务架构的好处。即使在合适的情况下将系统分解为四五个较小的服务，也可以显著改善代码健康状况。

你可能听说过微服务是唯一好的架构模式；这是不真实的。这种看法源于许多单体设计不良或没有得到解锁生产力所需的技术债务关注和投资。所有微服务架构都令人愉快的想法也是不真实的。有许多微服务实现由于某种原因也未能实现其好处。

SOA或微服务系统的主要特征：

* 不同的服务可以独立部署和扩展。
* 代码由单个源代码仓库或多个代码仓库管理。
* 信息通过网络在系统各部分之间移动，通常通过HTTP、RPC（远程过程调用）或队列系统。
* 数据契约必须有意设计并深思熟虑，因为契约被实现为API并通过网络通信。

##### 在面向服务架构和单体之间选择

一般来说，单体比SOA更容易设置，并且需要的技术后勤管理要少得多。因此，对于绝大多数问题，单体是第一天的正确答案。如果团队在设计单体时非常自律和深思熟虑，它可以永远与团队一起扩展。然而，这并不适用于所有人。对于许多团队/项目，单体缺乏强制契约、无法作为独立组件扩展以及缺乏强制关注点分离将成为生产力的障碍。

如果你确实发现自己在与一个难以管理的单体作斗争，这并不意味着你的工程师不擅长他们的工作。软件工程的本质是需求变化和系统演进。维护单体可能意味着，有时需要投入大量资源来更新系统设计以进行演进，正是当团队未能进行这种投资时，单体复杂性才会成为生产力的障碍。

在某些情况下，迁移到面向服务架构显然是正确的选择：

你的服务具有需要独立扩展的元素。例如，一个功能消耗大量CPU资源，你不希望它干扰其他功能，或者你更愿意不支付扩展所有功能的费用，而独立扩展那一部分更具成本效益。

你正在开发需要公开自己独立API并拥有自己独占数据领域的功能，与主系统分开。特别是如果这个API旨在为外部客户提供服务，那么让这个功能作为自己的服务存在显然是一个好选择。

由于某种原因，你需要使用另一种编程语言作为应用程序的一部分。一个好例子可能是因为Python中有一个强大且高质量的框架来解决某种问题，但你的应用程序的其余部分是用Java编写的。在内存中桥接这两种语言是可能的，但很笨拙。更简单的选项是通过API桥接它们，让它们自然地作为独立服务托管。

部署你的单体过于昂贵、缓慢或有风险。在这种情况下，你可以通过将新代码作为独立服务部署来实现额外的生产力并减少部署时间。只需确保新服务独立于单体运行，并且你不会创建新的部署依赖关系。

##### 面向服务架构的源代码控制：单仓库和多仓库

管理单体的源代码相当简单，因为它存在于具有单一构建系统的单个仓库中。一旦你开始将代码分解为不同的包、项目和服务，你就面临一个决策：你是在单个代码仓库中管理多个服务，还是创建多个仓库？这种权衡被称为单仓库与多仓库。

如果你选择将多个服务作为单仓库管理，你可能需要寻找工作区管理解决方案（例如，JavaScript生态系统的yarn workspaces）来分别管理项目的构建。以下是单仓库和多仓库方法之间的一些基本差异：

**单仓库的优缺点
TODO: 在这里放置图表

很容易确保每个服务或包依赖项都使用最新版本更新。

许多CI系统本身不支持单个仓库中的多个包，因此你必须手动构建工具来支持这一点。

将所有代码放在单个仓库中可以提高可发现性，使开发人员更容易找到他们正在寻找的模块或引用。IDE对这种搜索有强大的支持。

**相比之下，多仓库**

需要使用具有版本控制的中央包管理器。这不一定是坏事，但在同时处理项目及其依赖项时可能会导致大量开销。

与CI/CD管道系统（Bitbucket pipelines、GitHub actions等）集成清晰。

我的一般建议是保持简单。对于中小型项目，单仓库会更简单易于设置和维护。过渡到多仓库意味着愿意在工具上进行投资，以确保多仓库对你的开发人员顺利运行；这是一项重大成本。对于一家小型创业公司来说，这个成本可能不值得。另一方面，如果你正在快速增长或超过五十名开发人员，单仓库变得难以管理，并且你有一个专门的内部平台或DevOps团队可以承担使多仓库易于使用的繁重工作，那么过渡到多仓库模式可能是正确的选择。

##### 分布式单体

分布式单体是一个部署为多个服务的系统，这些服务没有设计足够的独立性或隔离性，因此不能独立部署。明确地说，这是两全其败。它不是让开发人员能够去任何服务并孤立地工作，不考虑任何其他服务，而是要求开发人员推理该服务如何影响其他服务。不仅如此，他们可能还必须在多个服务中进行更改，并在服务之间协调特定顺序的部署，以确保发布期间的兼容性。这种开发和部署复杂性抵消了微服务系统的主要好处。

如果你注意到你的团队陷入这些模式或抱怨在服务之间协调发布，这应该是一个危险信号，让你更仔细地查看并考虑偿还一些技术债务，以回到可独立部署的服务。这种技术债务通常位于你的契约、API设计以及系统中数据处理方式。

### 编写可读的、好的代码

在专业环境中，任何给定代码行的主要受众不是计算机，而是将来某个时候必须读取该代码以进行进一步开发的开发人员。这是编程的黄金法则：工程师应该以他们期望其他人代码相同的可读性水平编写代码。

#### 语言和生态系统的选择

根据编程的黄金法则，你选择的语言应该使你的团队能够编写高度可读和可维护的代码。一般来说，优秀的工程师可以用任何语言做到这一点；然而，某些语言比其他语言更容易一致地做到这一点。选择什么语言或生态系统的其他一些考虑因素：

* 熟悉该语言的人才库有多大，更具体地说，熟悉该环境并且对像你这样的创业公司感兴趣的人才有多少？
* 是否有可以用作起点的现有实现？
* 你有特定的性能或扩展要求吗？某些语言对于特定类型的任务要快得多。Haskell在字符串操作方面效率低下是出了名的，C在大多数事情上速度很快是出了名的，尽管对于某些问题，还有其他语言在提供更简单和更友好的编码环境的同时接近或超过C的速度。
* 是否有特定的框架可能是特定语言的良好起点？例如，React Native是一个强大的跨平台移动语言，需要JavaScript或TypeScript。

在企业环境中，我推荐具有静态类型系统的语言，如Golang、TypeScript、Rust等。使用静态类型系统，编译器会为确保代码正确性做更多的繁重工作。你应该努力建立一个本地开发环境，在代码执行之前工具就能发现错误。修复编译时问题通常比修复运行时问题要快得多，成本也低得多。

#### 代码风格和格式化

在任何广泛使用的语言中，都会有代码应该如何格式化的已发布标准（例如，Python中的PEP8）或可以强制执行特定代码风格和格式化的可配置工具（例如，JavaScript中的ESLint或Prettier，或C#中的ReSharper）。这些工具中的大多数都非常擅长确保代码，无论谁编写的，在风格上都是相同的。本着确保你的代码库可读的精神，没有理由不使用这些工具之一并确保你的代码库100％按照相同的规则格式化。你使用哪些规则完全是你和你的团队的偏好，但要确保它是一致的并产生可读的结果。

我建议你为开发人员使用的集成开发环境（IDE）设置一组配置选项或说明，说明如何在保存文件时自动格式化代码。然后，你应该在持续集成系统中确保所有新代码都正确格式化。

要小心：在没有自动格式化的情况下在持续集成系统中强制执行风格对工程师来说非常令人沮丧，因此确保从第一天开始就培训每个人正确设置他们的IDE，以避免CI中lint失败带来的一致性惊喜和浪费的周期时间。

#### 静态代码分析

现代静态代码分析能够识别并警告广泛的常见代码问题，从安全漏洞到彻底的错误再到风格不一致。这些工具相当便宜，并且与广泛使用的持续集成系统和开发人员IDE整合得很好。根据在一系列项目和编程语言上使用这些工具的经验，信噪比非常好，输出是生产力和软件质量的净增益。在软件项目生命周期的相对早期，你应该集成静态代码分析。我鼓励你查看特定于你选择的编程语言的工具，例如JavaScript的ESLint，以及通用分析平台，如SonarCloud、Codebeat、Scrutinizer-CI、Code Climate或Cloudacity。

#### 绿地与棕地

绿地软件开发是指在具有最少预先存在的遗留代码的新环境中进行的开发工作，并且可以自由选择工具、模式和架构。这具有明显的优势，可以为工作选择正确的架构和工具，并且不受现有技术债务的干扰。微妙的缺点是，有这么多选择和这么少的约束，做出不良决策的风险更高。对于新项目，通常还有相当大的引导成本被低估了，比如设置测试、构建系统、静态代码分析等。

棕地软件开发是指与现有遗留系统一起工作的绿地相反。权衡本质上是相反的：无论好坏，你都被之前的人做出的高层决策所困扰。

棕地开发中最大的风险是"非我发明"综合症。"非我发明"是个人倾向于避免对他们自己没有创建的东西承担责任或给予足够关注。在棕地软件开发中，这可能导致对理解现有工作的系统性投资不足，导致在增强或修改现有系统时产生挫折和低效。我强烈鼓励管理者明确为团队创造空间，让他们在被要求以任何方式修改现有系统之前阅读和理解它。在理解上预先花费的时间将通过更少的意外和更快的速度在未来得到回报。

### 编码模式

对于许多编码人员来说，编写什么风格的代码是一个宗教讨论。我在本章的目的是简要描述编码模式中最常见的短语是什么意思，并向你介绍有关每种实践的更广泛的资源。

如果你面临的是在这个主题上感觉像是情绪化的对话，请记住，使用这些模式中的每一种都存在许多成功的公司。一切都是权衡。糟糕的程序员可以用任何工具制造混乱，相反，优秀的程序员即使使用次优工具也会找到制作可读解决方案的方法。

#### 面向对象编程（OOP）

面向对象编程（OOP）是一种将代码设计为镜像现实世界名词和动词的方法。一个典型的例子是将两个人之间的交互建模为两个Person对象，而人的任何动作，如说话，将是这些对象上的函数。许多语言本质上是面向对象的，如Python、Ruby和C#。有些，如JavaScript或C++，是对象可选的（在一定程度上支持面向对象和函数式风格），而其他则是完全不同的东西。

#### 纯粹性

纯粹的代码没有外部依赖或副作用。换句话说，给定相同的输入，纯粹的代码总是产生相同的输出。纯粹代码的优点是它易于测试，不需要外部设置或模拟。纯粹的代码也更容易阅读和理解，因为它不需要阅读任何额外的代码来理解它的作用。纯粹代码的一个简单例子是将两个数字相加的函数；给定任意两个输入数字，求和函数总是产生相同的输出。

有些代码本质上是不纯粹的，例如，与外部世界交互的代码，如文件系统、网络或数据库。对于大多数其他情况，可以以纯粹的方式建模业务逻辑。在可能的情况下，我鼓励你和你的团队编写纯粹的代码。

#### 函数式编程

继续使用语法部分模型来描述编码模式，函数式编程将动词（函数）视为系统的一等部分。大多数函数式编程从非常小的功能片段开始，并将其组合在一起以创建更复杂和复杂的系统。当做得好时，函数式代码的好处是它往往更纯粹，因此更易于阅读、推理和孤立测试。函数式代码的学术例子甚至存在，可以正式推理，这意味着可以产生代码正确运行的数学证明。

函数式编程，如果做得不好，可能会创建非常冗长且难以阅读的代码。例如，在将多个函数组合在一起时，重要的是要考虑正在组合多少个函数，以及组合链中每个函数的行为有多明显。

最坏的情况：想象一个连续十个函数的函数链，每个函数的名称对你没有任何意义（例如，a(b(c(d(e(f(g(h(i(j(input))))))))))）。唯一更糟糕的是，如果这些字母函数的定义在代码库的不同位置的十个不同文件中，或者更糟糕的是，来自不同的导入库。

#### 极限编程和测试驱动开发（TDD）

极限编程是一种开发方法，类似于敏捷或SCRUM。它可以用来引用Kent Beck的书《极限编程解析》中描述的正式方法，或者更非正式地用来处理该方法所倡导的一些编码实践。该短语的非正式用法描述了方法中的测试实践，特别是测试驱动开发的想法。

测试驱动开发（TDD）是一个过程，其中测试是在功能软件之前编写的，而不是先编写功能代码然后再编写测试。行为驱动开发（BDD）和验收测试驱动开发（ATDD）是类似的实践。

#### 依赖注入

依赖注入是一种模式，其中特定对象、模块或代码块的服务依赖项被传入，而不是实例化。例如，数据对象可以通过在配置文件中查找连接字符串并创建数据库客户端来实例化自己与数据库的连接。或者，父调用代码块可以创建数据库服务，然后将单个数据库服务传递到数据对象的每个实例中。

依赖注入的主要优点是它减少了服务与其依赖项之间的耦合，有效地在它们之间添加了一个文档化的接口。例如，这个接口允许使用接口的其他实现，例如在测试上下文中的模拟服务。

干净地进行依赖注入存在微妙之处。我鼓励你采用你的编程语言常用且深思熟虑的框架或模式。

#### 领域驱动设计

领域驱动设计这个术语来自Eric Evans于2003年出版的书《领域驱动设计》。核心思想是创建一个模型，无论是面向对象设计中的对象还是数据库的模式，以建模你的业务领域中的名词。这可能看起来简单直观；然而，对于复杂的业务领域，代码很容易不一致地建模领域，或者以妨碍团队理解的方式建模它。特别是对于更大更复杂的问题，我总是坚持团队坐下来就一致的方式建模问题达成一致，在整个系统中使用一致的术语来指代相同的概念。

### API契约

应用程序编程接口（API）与法律合同没有什么不同。

它是在实现之前设计、调整和商定的，双方都期望对方遵守合同以实现期望的结果。当你设计和实现API时，你向API的消费者承诺它将以某种方式工作。就像法律合同一样，你可能对API如何运作有特定的想法，但如果细微差别被另一方不同地解释，你可能无法实现你的目的。API细节确实很重要，作为技术领导者，你的角色是确保你的团队以一致、高效的方式设计和构建API。

尽管如此，构建高质量的API是一项令人惊讶的复杂任务。它需要考虑很多事情：设计接口、实现处理逻辑/数据的代码、测试功能、构建文档、处理版本控制/变更管理、在API更改时保持文档最新，以及使开发人员易于与API交互。做好这些事情可能意味着构建开发人员喜欢的API和阻碍实现并减慢重要项目启动时间的API之间的区别。作为领导者，你有两个主要杠杆可以确保你很好地处理这些事情：治理和架构。

#### API设计治理

构建API的每个元素都涉及无数决策。将好的API与坏的API区分开的是这些决策的一致性、可预测性和正确性。作为技术领导者，你的工作是确保在你的组织中，你有一个结构来帮助开发人员构建彼此一致的API，可预测的是它们使用适合手头问题的常见模式，并且是正确的。

实现这些目标需要某种形式的治理系统。这可以从一组明确记录的指南和标准到一群定期负责审查和批准所有API的人员。你的团队越大，你就需要在流程和治理方面投入越多的时间和精力来维持高标准。

#### API架构

在野外，你可能会遇到两种主要类型的API：基于HTTP的和非HTTP的。与任何工具一样，HTTP有其权衡，并不适合每项工作，因此如果你的业务需求要求超低延迟、超高吞吐量/低开销或实时流应用程序，你可能会寻找超越HTTP的东西。下面我将讨论一些HTTP API类型，然后简要介绍一些你可能遇到的非HTTP API。

#### 基于HTTP的API

如果你正在构建Web或移动应用程序，甚至大多数系统后端，很可能你主要会处理HTTP API。

*XML和SOAP API*

在2000年代初，最常见的API模式是基于XML的简单对象访问协议（SOAP）。SOAP和其他基于XML的API风格在2020年代的创业公司中已经完全过时，但它们在遗留系统中仍然普遍存在，特别是在技术移动缓慢的行业中的大公司。你不应该构建新的SOAP或基于XML的API。

*REST*

REST（表述性状态转移）是一个通用短语，描述使用JSON over HTTP作为API。REST有时会用一种称为HATEOAS的模式进行增强，它为REST API的内容/有效负载提供了一套更正式的标准。没有HATEOAS（这并不那么常见），REST不包括关于如何建模JSON数据的正式或品牌指导。REST API通常将单个名词建模为端点，并使用HTTP动词（GET、PUT、POST、DELETE等）来确定对名词的操作。例如，GET `/users`将列出用户，POST `/users`将创建新用户，DELETE `/users/123`将删除ID为123的用户。

REST可能是你会遇到的最常见的API形式。REST拥有广泛而强大的工具生态系统，几乎每个工程师都熟悉它。

*GraphQL*

GraphQL与REST类似，它是JSON over HTTP；然而，它不依赖HTTP动词。GraphQL上几乎所有内容都是POST，它使用结构化的查询和变更模式。

我喜欢将GraphQL视为带有类型和自文档化模式的REST。因此，GraphQL API往往带有自动生成的文档和模式浏览器。GraphQL还通过其模式系统，允许将多个服务的多个模式组合成一个更大、更强大和更复杂的数据图，有时称为联合模式。Apollo公司为管理和扩展图提供了复杂的解决方案。

构建图来建模公司数据的好处有很多要说的，被迫设计模式带来的良好习惯也是如此。也就是说，没有系统是没有权衡的。因为GraphQL放弃了标准的HTTP动词，它不能很好地与Web堆栈的某些元素配合使用。GET请求缓存和开发人员工具仍在努力与GraphQL请求友好配合。如果这些缺点对你的业务不是重大关注，我强烈鼓励你查看apollographql.com并考虑使用GraphQL，特别是用于你的API的内部用例。

#### 非HTTP API

一般来说，对于传统的同步请求/响应（又称远程过程调用或RPC）风格的API，由于其无处不在的性质，你会想要使用HTTP API。然而，有几种API模式，特别是对于异步操作，它们不能很好地映射到HTTP，并且有常用的替代实现。

*队列系统*

队列系统维护一个收件箱（或一组收件箱）来接收消息，以及一个供消费者以某些保证读取消息的接口。

典型的队列系统可以保证消息顺序（先进先出，FIFO；或后进先出，LIFO）以及至少一次或最多一次交付。大多数云平台都有队列的托管实现，例如AWS简单队列服务（SQS）或Google Cloud任务队列。

队列系统通常具有*显式*调用的概念，也就是说，当发布者创建消息时，它会明确指定应如何处理或执行请求。相比之下，大多数发布者-订阅者系统支持*隐式*执行。这意味着发布者不一定事先知道哪个系统将处理消息，只知道发布/订阅系统将交付它。

*发布者-订阅者（pub/sub）模式*

发布者-订阅者模式，缩写为pub/sub，允许设计一个系统，其中消息由潜在的多个源创建，并通过各种模式交付给潜在的多个订阅者。发布者-订阅者关系被建模为一对一（直接）、一对多（扇出）、多对一（扇入）和多对多。各种pub/sub实现可以提供保证，消息被交付给所有订阅者、至少一个订阅者、至少一次等。与队列类似，有现成的解决方案，如RabbitMQ，以及易于扩展的云托管选项，如Amazon简单通知服务（SNS）或Google Cloud Pub/Sub。

pub/sub模式及其提供的保证非常强大。然而，权衡是实现需要一些关心和对细节的关注，以实现宣传的保证。例如，实现订阅者需要密切关注消息确认语义，并仔细管理主题订阅，以确保正确的消息到达正确的位置。

如果你在使用队列、pub/sub或HTTP API实现解决方案之间犹豫不决，我的一般建议是保持简单并使用同步HTTP API。你在实现之间犹豫不决的事实表明，异步系统提供的保证对你的实现并不重要，因此增加的复杂性可能不值得你的创业项目。

*作业系统*

作业或cron作业是一种后端API类型，很少由发布者或客户端触发，而是由某种形式的计时器触发。常见的例子包括夜间数据清理任务，或发送每周电子邮件摘要/通知。作业的一些最佳实践：

* 使用由其他人维护的作业系统，不要自己构建一个。
* 在选择作业系统时（或者如果必须自己构建），请确保它：
  - 为每个作业执行记录日志；
  - 允许配置失败作业的重试；
  - 在作业失败时提供通知。工程师设置计划作业，在第一天观察它工作，然后在第十五天失败，直到第三十天才有人注意到，这是非常常见的；
  - 提供一个界面来查看作业和作业状态；
  - 允许将作业配置作为代码或配置存储在源代码控制中；
  - 允许作业在你的环境/专用网络/安全组内运行，以根据需要访问其他内部系统API/资源；
  - 与你的密钥管理系统集成。
  - 允许轻松地在开发和生产环境中本地设置作业，并在这些环境中轻松测试。

### 文档

拥有全面、清晰和最新的API文档与你如何构建和维护它一样重要。优秀的API文档的一些关键特征：

* 始终与实现保持最新
* 记录所有可能的输入及其类型记录所有可能的错误
* 易于其他工程师阅读和导航

使用包含API文档生成的系统来构建API总是一个好主意。否则意味着在一致的基础上满足所有这些目标几乎是不可能的。如果你正在构建REST API，我强烈鼓励你使用OpenAPI（描述你的API的YAML或JSON文档）设计你的API。在大多数语言中，都有SDK可以使用OpenAPI规范并自动生成控制器/路由以匹配规范和/或生成测试工具以确保实现的API匹配规范。此外，还有在线工具，如stoplight.io和readme.com，可以使用OpenAPI文档并生成美观且易于导航的文档。

如果你使用GraphQL，GraphQL Playground或Apollo Studio浏览器可以为广泛的类型文档提供合理的替代品。我确实建议你仍然使用readme.com等工具或手动创建一个单独的API文档页面，作为入门或入门指南。内置的GraphQL文档缺少对身份验证如何工作的描述，它在提供空间来解释API中数据之间的关系方面也做得很差。

这些是你需要在其他地方填补的空白。

使用OpenAPI或GraphQL的另一个好处是，生成的API规范不仅可以移植到文档生成器和测试框架，还可以移植到开发人员IDE，如Insomnia或Postman。这些IDE使开发人员能够快速与API交互以验证功能，而无需编写代码。正式规范还可以与代码生成工具一起使用，以确保代码中的类型一致性。

### 幂等性

当多次发出相同请求与发出一次具有相同效果时，API请求被称为幂等的。幂等性是构建健壮系统和避免数据损坏的重要概念。与所有事情一样，幂等性为你提供了关于系统的有用保证，但它是有代价的：实现幂等性会增加后端系统的复杂性。

在REST API中，广泛假设除了POST之外的每个HTTP动词都应该是幂等的。例如，GET请求按定义应该始终为相同的输入返回相同的结果（当然，除非底层数据发生变化）。一般来说，PUT请求正在修改现有对象，应该自然是幂等的。然而，在大多数系统中，多次调用POST请求表示创建多个对象的意图。

#### 幂等性密钥

对于REST中的HTTP POST请求和GraphQL变更API，幂等性不是由标准/规范提供的。如果你希望客户端能够重试这些类型的请求并具有幂等行为，你应该实现幂等性密钥模式。幂等性密钥是由客户端提供的任意字符串（作为HTTP标头或可能在GraphQL中作为输入变量），后端使用它来去除重复的传入请求。这要求后端存储幂等性密钥，还要存储对具有该密钥的请求的响应，以便稍后提供给客户端。

请注意，实现幂等性密钥并非易事，因为它需要额外的数据库写入、围绕捕获请求响应的逻辑以及处理同时到达的重复请求的并发/锁定问题。如果幂等性在你的应用程序中很重要，比如，如果你正在处理金融交易，我鼓励你采用提供开箱即用的健壮幂等性系统的后端API实现，而不是从头开始构建它。

## 数据和分析

大多数创业公司至少有三种不同类型的数据作为其业务的一部分：

* 事务性数据

* 分析性商业智能数据

* 行为数据

这些类型的数据中的每一种都将以不同的数量出现，具有不同的读/写模式，并需要不同的工具来可视化和获取洞察。

关于"大数据"这个短语的快速说明。作为一家创业公司，很可能你*没有*需要考虑无限规模（或网络规模）的大数据。典型的现成数据库，配备合理数量的硬件和半体面的数据模型设计，完全有能力以可接受的性能处理数千万行和数百GB的数据。大多数大数据解决方案，如数据管道或数据仓库设备，涉及大量额外的设置复杂性、延迟和成本，对于你的创业公司来说可能是过度的。为了简单起见，只有在你能提出令人信服的论据证明常规（例如PostgreSQL）数据库无法完成工作时，才应考虑大数据解决方案。换句话说，不要过早优化你的数据库架构。

### 事务性数据

事务性数据是为你的应用程序本身提供动力的数据，通常是你的主要NoSQL或SQL数据库。事务性数据需要非常低的延迟和高可用性，与其他形式的数据相比，总大小适中。我的建议是选择一个现成的SQL或NoSQL解决方案，最好是为你托管的东西，如MongoDB Atlas或Google Cloud SQL。生产数据库中的一些有用功能：

* 一键时间点恢复
* 定期备份与一键恢复
* 用于负载分流的只读副本
* 多区域复制和托管以实现可用性
* 基于事件的审计日志
* 自动磁盘扩展/收缩
* 连接/IP级别的安全性
* 资源（CPU、RAM、磁盘、网络）监控和警报，一键扩展CPU/RAM
* 慢查询监控

### 分析性商业智能数据

商业智能（BI）是用于深入了解用户行为的数据，通常来自你的事务性数据。早期，你通常可以直接在事务性数据库上运行商业智能查询。随着数据大小和查询复杂性的增加，这变得更加有问题，因为它会给需要高可用性和低延迟的系统增加额外的负载。那么自然的解决方案是查询事务性数据库的只读副本，或通过数据管道将数据复制/转换到另一个数据存储系统。

构建数据管道和数据仓库本身就是一本完整的书，并且最先进的技术总是在不断发展。我只有几个高层次的建议：

考虑为你的主要商业智能数据仓库查看企业数据解决方案，如Snowflake、Databricks或Google BigQuery。这些工具是游戏改变者。特别是无服务器仓库（BigQuery、Aurora）设置起来很简单，无论数据大小如何都具有相当一致的延迟，并且对于早期/中期创业公司来说具有很高的成本效益。

在现代，创业公司不需要构建和托管复杂的数据管道架构。ELT（提取、加载、转换）和ETL（提取、转换、加载）工具现在可以完全在企业数据库数据湖/仓库内运行，而dbt等工具提供可重复性、可测试性和管道即代码功能，使运行数据管道变得更加可管理。

考虑使用托管或云原生解决方案来可视化数据，如Looker、Domo或Preset。

确保你的工程和产品团队与你团队中拥有数据和商业智能的成员密切合作。在产品流程的早期引入数据的视角将节省大量麻烦，遵循"测量两次，创建数据模式一次"的心态。

### 行为数据

行为数据，也称为行为分析事件，描述了用户如何使用你的应用程序。行为数据通常数量相当大，模式有些有限，最好与强大的可视化软件结合使用。

总体而言，你希望来自应用程序的行为数据发送到多个来源。这带来了一个路由问题：你有一个单一的数据源（你的应用程序），但你希望事件发送到许多地方。这个问题的几乎普遍采用的解决方案是Twilio的Segment平台，尽管有一些新兴的替代方案称为客户数据平台（CDP），如RudderStack。CDP可以从你的应用程序中摄取数据，然后将其发送到你的数据仓库以及你喜欢的尽可能多的其他SaaS平台。

你的应用程序生成的行为数据与事务性数据之间的一个重要区别是其精度。大多数行为数据是有损的——用户有广告拦截器，请求被丢弃，或防火墙阻碍。事件可能无法从客户端设备到达你的CDP的原因有很多。这并不意味着行为数据没有用，但意识到其有损性应该告知你对数据的期望，并限制查询时的用例。如果你需要准确的数字，期望从你的BI平台和事务性数据中获得这些数字。

### 架构设计的一般提示和最佳实践

让我们用一些设计架构的总体建议来结束本节。

#### 将业务逻辑放在后端

当你构建应用程序时，你经常面临逻辑应该在哪里存在的选择：在客户端（例如，Web浏览器、移动设备、物理硬件）还是某种形式的后端服务器。对于某些类型的逻辑，例如与身份验证、价值计算、反作弊/篡改机制相关的任何内容，这是一个硬性要求。对于大多数其他逻辑，出于以下原因，这仍然是一个好主意：

后端通常比客户端更容易测试，因此你可以更自信地确认后端上业务逻辑的正确性。

后端上的更多逻辑意味着更薄的客户端，也意味着你可以为多个平台生成可以利用单一逻辑源的客户端，减少代码重复。

后端上的逻辑不能被客户端篡改或修改。

#### 使服务可外部化

从你的后端到其他后端，或从你的后端到前端的API，应该被视为可以被第三方使用的通用目的API。这迫使你保持几个良好的设计习惯，包括确保接口本身是可理解的（领域驱动设计），并在数据设计中使用合理的身份验证机制和适当的高级所有权抽象。而且，万一你有一天希望外部化服务，这样做的路将会短得多。

#### 使用尽可能少的语言

每种编程语言都带有相关的构建系统、依赖管理系统、编程最佳实践和接口。你的团队应该投入大量精力来确保你的主要语言和生态系统集成良好，并且对本地开发人员、测试环境和生产环境都运行良好。

对于你添加到堆栈中的每种额外语言，你都需要复制所有这些努力，并且你将遭受无法在运行时之间共享代码的痛苦。在允许在你的堆栈中添加额外的语言之前，你应该能够建立一个强大且防弹的论点，证明新语言的好处远远超过新语言增加的运营和维护负担。否则，你最好不使用它。


## 工具

软件工程的工具生态系统和模式不断发展和变化。你不可避免地会受到诱惑，无论是你自己还是你的团队成员，去改变你如何进行工程设计的某些方面，例如采用新库、框架、语言或模式。采用这些变化中的每一个都会迅速导致思考不周的架构拼凑而成。相反，忽视所有变化会让你拥有一个过时的代码库，随着时间的推移，它将变得效率更低，对新雇用的人才来说更难以工作。正确的方法是将更改技术堆栈的过程正式化，并提供一些护栏来激励你的团队对工具变化保持好奇和深思熟虑。

### 实施内部技术雷达

Thoughtworks是一家总部位于旧金山的领先软件咨询公司，发布了一个名为技术雷达（ctohb.com/radar）的工具，该工具评估Thoughtworks每年看到的数百个项目。他们根据新工具、技术、模式和语言（他们称之为blip）在现实世界中的有效性将它们放入四个类别之一。

这些类别是搁置（hold）、评估（assess）、试用（trial）和采用（adopt）。

如果你从未阅读过Thoughtworks雷达，我强烈推荐它作为了解正在发生的事情的一般入门，也作为你自己团队流程的灵感。

我平衡保持工程师积极性和代码库相关性与工具流失挑战的首选方法是遵循Thoughtworks的领导并实施内部技术雷达。与Thoughtworks评估新事物的普遍吸引力不同，我的方法使用相同的四个级别评估blip对我们组织的适合性和有效性。具体来说：

1. 有人提议使用新工具、技术、平台或语言（blip）。该提案最初被归类为"评估"。提议者必须在技术文档中证明新blip将为业务已经选择的项目（或作为创新冲刺中的实验，请参见冷却/创新冲刺，第163页）提供实质性好处。然后，如果获得批准，它将进入试用。
2. 开发人员在项目中使用新blip，无论是由业务选择还是在他们的创新冲刺窗口中。在项目结束时，作者会制作一份后续书面文档，描述他们使用blip的经验，包括优缺点以及blip与公司其他工具生态系统的配合程度。
3. 根据试用的结果，整个团队将决定采用blip，解锁该blip供团队其他成员使用而无需进一步仪式，或将其移至搁置，这将需要新的试用和新的评估才能再次使用。如果试用在业务项目中失败，建议团队仔细考虑是否从该实现中删除blip以避免未来的维护问题。

在大多数情况下，我发现当blip试用失败时，它会相对较早失败，领导项目的工程师不会在最终交付的实现中包含blip。

### 无聊技术

无聊技术是Dan McKinley创造的一个短语，在ctohb.com/boring中概述。关键思想是你的团队的工作是提供功能来支持业务，大多数时候这不依赖于使用花哨的新工具。事实上，使用不无聊的东西通常有许多隐藏的成本，只有当你的团队充分认识到这些成本并相信好处更大时，才应该采用新工具。正如无聊技术所描述的，总成本 = 维护成本 - 速度收益。要考虑的一些隐藏成本：

* 不完整、不准确或不成熟的文档
* 围绕工具/技术的生态系统尚未完全开发，包括SDK和与其他工具的集成
* 遇到缺陷或缺少功能/特性的可能性更高
* 你的团队成员采用新工具的额外培训成本
* 保持该工具或包更新、修补安全漏洞等的负担

### 工具成本

现代创业公司将在软件即服务（SaaS）上花费大量资金是生活的事实。你的公司可能也不例外，因此当你发现在B轮融资之前在基础设施和工具上花费了一个或多个人员的费用时，不要感到惊讶。

### 预算

对于不同公司阶段的SaaS和工具支出，有一些已发布的基准，作为公司收入或总支出的百分比。

没有单一的精确基准，但似乎典型的SaaS销售成本（COGS）在收入的10％到30％之间。

了解你的支出并关注成本增长。在AWS中意外留下几台机器运行并在你的年度云托管账单中增加10,000美元是非常容易的。大多数云平台都有内置的预算功能，因此没有理由不使用它们。如果你使用基础设施即代码，很容易设置一个模块，对于每个部署的新云系统，将同时自动应用云预算，该预算将监控并警报该特定系统的成本。

SaaS成本随着时间的推移而增长是典型的，无论是因为你的基础设施正在增长，还是因为你发现了一个可以为你的团队节省时间的新SaaS供应商。我建议不要使用成本作为避免采用典型SaaS工具（成本范围在每月数百美元）的理由。相反，我建议将定期增长纳入你的SaaS成本预测。

### 跟踪

你应该跟踪你的组织在工程工具上花费了多少，包括IDE、SaaS和基础设施（云平台）。你可以在电子表格中手动执行此操作，也可以使用SaaS管理平台（SMP）。这些解决方案可从BetterCloud、Zluri和Vendr等各种供应商处获得，这些解决方案与你的信用卡或银行链接并自动对现金支出进行分类。

## DevOps

维基百科将DevOps描述为一组结合软件开发和IT运营的实践。它旨在缩短系统开发生命周期，并以高软件质量提供持续交付。

对我来说，这个定义的关键部分是DevOps旨在缩短软件开发生命周期，换句话说，DevOps是更广泛团队生产力的推动者。如果你还没有专门考虑DevOps，你可能在某种程度上低估或投资不足DevOps。这不仅仅是我的意见；整个科技行业越来越普遍地接受，高质量的DevOps是整体工程速度的关键驱动力。


### 四个关键指标（DORA）

2022年Thoughtworks技术雷达（ctohb.com/techradar）中评级最高的blip是四个关键指标。这些指标由Google Cloud内的一个团队DORA（DevOps研究和评估）描述，该指标系统来自一个为期七年以上的研究项目，验证结果及其对技术、流程、文化和定量结果的影响。四个指标如下：

**前置时间：** 代码从提交到在生产环境中运行需要多长时间

**部署频率：** 代码发布到生产环境/最终用户的频率

**平均恢复时间（MTTR）：** 在事件/缺陷发生后恢复服务需要多长时间

**变更失败百分比：** 生产发布需要热修复、回滚、补丁等的百分比

这些指标共同量化了你的团队部署软件的信心。在所有四个指标上得分高需要在自动化、DevOps、测试和文化方面进行投资。正如Thoughtworks快速指出的那样，从这些指标中获取价值不一定需要高度详细的仪器、指标或仪表板。DORA发布了一个快速检查调查（ctohb.com/dora），你的团队可以在粗粒度级别跟踪其进度。还有许多工具的进入门槛相当低，可以产生足以告知你进度的数据质量，如LinearB或Code Climate。

以下关于DevOps的小节介绍了以某种方式有助于改善这些指标的概念、学科和重点领域。

### 可重复性

部署代码是一项高度微妙的活动，需要极高的精度。配置文件中的单个错位字符可能导致服务无法启动。更糟糕的是，对于大多数工程师来说，调试DevOps问题缓慢而痛苦，识别和修复该单个字符错误可能意味着在调试和修复中可能损失数小时的时间。我们都是人；这些类型的错误是不可避免的。由于它们在DevOps中如此昂贵，因此必须建立系统以最小化人为错误的机会。最小化DevOps中人为错误频率和影响的关键组成部分是可重复性的概念。

可重复性意味着我们有能力第二次做某事，既便宜又保证与第一次做的方式相同。DevOps中的可重复性需要自动化和工具。可以说，DevOps工具带中用于改善可重复性和加速开发时间的最重要工具是容器化。紧随其后的是基础设施即代码（IaC）的想法。由于这些技术如此基础，我将在这里花一点时间介绍它们中的每一个。

### 容器化

解释容器在DevOps上下文中的作用的最常见方式是考虑名称的起源：来自集装箱。在集装箱标准化之前，如果你想跨海洋运输货物，你会以各种形式包装货物，从将其放在托盘上，存储在箱子或桶中，或简单地用布包裹。装卸以所有这些不同方式包装的货物是低效且容易出错的，主要是因为没有单一类型的起重机或手推车可以有效地移动所有货物。

将这种杂乱的方法与部署标准化集装箱进行比较，船和港口运营商可以使用单一形式因素，使用标准化设备和托运人以及为所有货物提供单一、灵活的包装形式。从历史上看，使用标准化集装箱解锁了一个范式转变，将全球航运成本降低了几个数量级。将软件打包在可以在任何系统上以相同方式运行的标准化容器中提供了类似的能力和效率提升。

你与容器交互的最常见方式是通过一个名为Docker的软件系统。Docker提供了一种声明性编程语言，让你在名为Dockerfile的文件中描述你希望如何设置系统，即需要安装哪些程序，文件去哪里，需要存在哪些依赖项。然后你将该文件构建到容器镜像中，该镜像提供了Dockerfile指定的整个文件系统的表示。然后可以将该镜像移动到具有Docker兼容容器运行时的任何其他机器上并运行，保证它将在具有完全相同文件和数据的隔离环境中启动，每次都是如此。

#### 容器管理最佳实践

##### 设计容器以构建一次/随处运行

构建容器一次（比如在CI中），以便它可以在你的各种环境中运行——生产、开发等。通过使用单个镜像，你可以保证完全相同的代码和完全相同的设置将完整地从开发过渡到生产。

要实现容器的随处运行，请将环境之间的任何差异提取到运行时容器环境变量中。

这些是密钥和配置，如连接字符串或主机名。或者，你可以在镜像中实现一个入口点脚本，在调用应用程序之前从中央密钥存储（例如，Amazon或Google Secret Manager、HashiCorp Vault等）下载必要的配置和密钥。

运行时密钥/配置下载策略的另一个好处是它可用于本地开发，避免开发人员需要手动获取密钥或要求另一个开发人员向他们发送密钥文件。

##### 在CI中构建镜像

本着可重复性的精神，我鼓励你使用自动化构建镜像，最好是持续集成的一部分。这确保了镜像本身以可重复的方式构建。

##### 使用托管注册表

一旦你构建容器镜像并四处移动它们，你将立即希望有组织地管理构建的镜像本身。我建议用从源代码控制派生的唯一值标记每个镜像，可能还带有时间戳（例如，构建镜像的提交的git哈希），并在镜像注册表中托管镜像。Dockerhub有一个私有注册表产品，所有主要云平台也提供托管镜像注册表。

许多托管注册表还将提供附加到其镜像注册表的漏洞扫描和其他安全功能。

##### 保持镜像大小尽可能小

较小的Docker镜像从CI上传更快，下载到应用程序服务器更快，启动更快。从操作角度来看，上传50MB镜像和5GB镜像之间的差异可能是启动新应用程序服务器的五秒钟和五分钟之间的差异。这是在你的部署时间、平均恢复时间/回滚等中增加的五分钟。这可能看起来不多，但特别是在热修复场景中，或者当你管理数百个应用程序服务器时，这些延迟会累积并产生真正的业务影响。

#### Dockerfile最佳实践

Dockerfile中的每一行或命令都会生成所谓的层——实际上是整个镜像硬盘的快照。后续层存储层之间的增量。容器镜像是这些层的集合和组合。

因此，你可以通过保持各个层小来最小化容器的总镜像大小，并且你可以通过确保每个命令在移动到下一个命令之前清理任何不必要的数据来最小化层。

保持镜像大小的另一种技术是使用多阶段构建。多阶段构建有点太复杂，无法在这里描述，但你可以在ctohb.com/docker查看Docker自己的文章。

#### 容器编排

现在你已经获得了在托管注册表中管理的合理小尺寸的可重复镜像，你必须在生产环境中运行和管理它们。管理包括：

* 在机器上下载和运行容器
* 在容器/机器和其他服务之间设置安全网络
* 配置服务发现/DNS
* 管理容器的配置和密钥
* 随负载自动上下扩展服务
* 有两种容器管理的一般方法：托管和自我管理。

##### 托管容器管理

除非你的要求是独特的或你的规模非常大，否则你将从使用托管解决方案中获得最高的投资回报率，该解决方案为你完成管理生产容器的大部分工作。对这些解决方案的常见且公平的批评是，它们往往比自我管理的选项贵得多，并且提供的功能更少，限制更多。作为交换，你可以获得显著更少的开销和复杂性，对于大多数创业公司来说，这是一个非常值得做的权衡。大多数小团队缺乏有效自我托管的专业知识，因此自我托管最终要么需要现有团队成员进行大量时间投资，要么迫使你在早期雇用昂贵的DevOps专家。每月额外花费1,000美元来避免这些问题可能会提供非常好的投资回报率。

一些常见的托管容器平台包括Heroku、Google App Engine、Elastic Beanstalk、Google Cloud Run。Vercel是另一个流行的托管后端解决方案，尽管它不像这里描述的那样运行容器。

##### 自我管理/Kubernetes

容器最流行的自我管理解决方案称为Kubernetes，通常缩写为K8s。Kubernetes是一个极其强大和灵活的，因此也是复杂的系统。学习曲线很陡，但如果你需要自我管理容器，好处和投资回报率是值得的。

如果你正在考虑走这条路，我强烈建议不要在工作中学习Kubernetes。特别是对于团队领导者来说，以临时方式承担和做好这件事太多了。相反，我建议购买一本关于Kubernetes的书，并花一两周时间阅读它并设置你自己的沙箱以加快速度，然后再投入专业项目。寻找一个对Kubernetes有很好理解的顾问或导师作为你学习工具的加速器也是一个好主意。

#### ClickOps与IaC

ClickOps指的是使用用户界面配置云基础设施的过程，而不是使用提供的API。随着你的基础设施增长，系统中的细微差别和细节数量将很快超过你使用ClickOps重现它的能力。ClickOps适用于原型或概念验证，但当真正构建生产环境和镜像开发环境的时候到来时，使用ClickOps将迅速导致相当大的挫折和成本，以及有限的能力。ClickOps的替代方案称为基础设施即代码（IaC）。

有几种工具和框架允许你定义IaC。领先的是HashiCorp的Terraform。Terraform使用HashiCorp配置语言（HCL），这是一种声明性配置语法，允许工程师定义他们想要什么资源以及如何配置它们。然后可以像管理任何其他代码一样管理Terraform代码，使用源代码控制和同行评审实践。一旦获得批准，Terraform可以生成基础设施变更计划，并为你应用这些计划到你选择的云提供商。我无法充分强调Terraform的易用性、强大性和可维护性，以及你通过从ClickOps迁移到IaC可能获得的投资回报率。

### 持续集成

持续集成是自动将新代码合并到项目中的过程。这可能包括对新代码运行静态分析、运行测试、构建代码以及生成任何所需的构建工件（如容器镜像）。大多数创业公司使用托管CI平台，如GitLab运行器、GitHub actions、Bitbucket管道、Jenkins或CircleCI来执行持续集成活动。

CI的一些最佳实践：

* 确保团队了解CI系统，并能够轻松地添加到它、更新新需求以及在事情不可避免地导致构建失败时进行故障排除。
* 确保构建是一致和确定性的。不可靠或不稳定的构建是一个极其强大的生产力流失和时间浪费。
* 尽量保持构建时间。对于大多数团队来说，一个好的目标是CI花费少于十五分钟。
* 学习CI工具的功能，这些功能有助于保持构建快速，包括构建缓存、构建工件和并行运行作业。
* 构建可能会变得复杂。尽量保持你的CI代码*干燥*。在可能的情况下在构建管道之间重用代码。
* 在构建访问密钥的方式上保持一致。要么依赖云密钥管理器，要么在必要时构建环境密钥，并尽量不要混合它们。应该有一种明显且一致的方式来处理配置和密钥。

### 持续部署

在项目的早期阶段，部署新代码相对简单。此时，没有太多的代码或架构复杂性。然而，不久之后，管理依赖项、依赖服务、CDN、防火墙、构建工件、构建配置、密钥等的需要导致复杂的部署过程。随着这些需求的积累，很容易忽视自动化，并简单地依赖，例如，一个专门且高度信任的个人作为发布经理。有无数的团队遵循这种模式，我保证你大多数这些发布经理都会提前在日历上圈出发布日期，并害怕这些日子不可避免地带来的压力、长时间和挫折。

幸运的是，有一个治愈易出错的压力集中的每月（或更长！）发布日的方法。它是每天发布，或者，嘿，每小时发布！从技术文化的十大支柱（见第138页）之一"频率降低难度"的逻辑来看，更频繁的发布将迫使你的发布经理和团队自动化部署的困难部分。经过足够的迭代，发布可以变得完全自动化，并且通过足够的测试给你对新变化的信心，你可以达到为每个代码变更集触发新发布的程度，称为持续部署。

除了通过自动化消除发布过程的复杂性外，更频繁地发布意味着每次发布的代码量更少。较小的代码更改对其他开发人员来说更容易审查。更小的更改，仅仅因为更小，提供了更少的缺陷机会。

自动化发布过程往往也意味着改进回滚更改或从生产问题中恢复的能力。这也被衡量为平均恢复时间（MTTR）。

总之，自动化发布意味着代码发布更快（减少前置时间），意味着你可以更频繁地部署（增加部署频率），并改善MTTR。这是四个关键DORA指标（见第208页）中的三个，只需一项举措！

在我直接或以咨询身份合作过的公司中，我看到至少十几个团队投入精力部分或完全转向持续部署。这并不总是一帆风顺的旅程，它不会在一夜之间发生，并且经常有合理的反对意见。然而，在每种情况下，当团队回顾投入的时间时——无论是三周、三个月还是两年后——按照每个指标来看，对团队的文化和整体产出和速度的差异都是变革性的。

### 功能分支环境

功能分支环境是一个托管环境和一组基础设施，可供你的公司内部使用，运行来自特定分支的代码。功能分支环境对于验证代码在类似生产的环境中工作以及使你公司的团队成员能够使用或测试更改而无需自己构建和运行代码非常有用。不要低估人类的懒惰；测试和验证你的代码所需的每一个额外步骤都意味着他们测试的频率会更低。检出代码、安装依赖项和启动服务器比访问自动生成的功能分支URL要多得多的工作，因此功能分支将被使用得多得多。

功能分支环境还解决了只有单个暂存环境的团队遇到的争用问题。我主张为每个分支提供自己的暂存环境。

功能分支环境的一些考虑因素：

* 自动化在这里是关键；手动设置功能分支环境几乎总是不切实际的。
* 在可能的情况下，使用诸如Vercel或Firebase之类的系统，该系统将功能分支环境作为一流功能包含在内，以最小化你的设置和维护成本。
* 仔细考虑如何处理功能分支环境中的数据。你需要回答以下问题：

  - 每个后端功能分支环境都获得一个新数据库吗？我的建议是肯定的。
  - 功能分支环境使用生产数据吗？我的建议是否定的。相反，使用生成与生产类似数量数据的种子脚本。有一个过程在必要时为开发人员复制、清理和恢复生产数据以进行调试是值得的。
  - 功能分支环境中如何处理数据库架构更改/迁移？
  - 服务发现在面向服务架构的功能分支环境中如何工作？通常，你可以拥有一组通用服务，并仅部署被测服务的功能分支版本。我建议你为每个服务提供一个始终运行的环境，称为集成。让所有功能分支引用其他服务的集成环境。每个集成环境更新都应该是生产更新，但你还应该允许开发人员暂时将功能分支代码部署到集成环境以进行跨服务集成测试。

看了这个关注列表后，你可能会被设置和维护功能分支的负担所吓倒。确实，适当的功能分支设置并不便宜，但它提供的价值在改善你的测试能力以及减少验证不同类型软件更改所需的后勤开销方面是巨大的。

### 管理DNS

了解域名系统（DNS）的工作原理，以及了解如何管理DNS及其对你公司的安全影响，是一项经常落在创业公司CTO身上的关键工作。如果你还不熟悉DNS工作原理和不同记录类型的基础知识，我建议你现在花几分钟浏览维基百科以获得对该主题的基础。

你还应该了解DNS如何用于你组织中的电子邮件。特别是，熟悉发送方策略框架（SPF）记录和DKIM/DMARC。

你还应该使用基础设施即代码（IaC）设置你的DNS记录。我见过无数公司，DNS仅由执行人员管理，其双因素身份验证是唯一允许更新区域记录的，当该人度假时，没有后备机制来管理站点。

更好的解决方案是使用Terraform设置DNS（它与所有主要DNS提供商集成），然后使用源代码控制管理DNS记录，使各个开发人员能够以负责任的方式添加新记录，而不受任何一个人的限制。

### 解耦发布代码与发布功能（功能开关）

在高层次上，功能开关是一个开关，允许你在不更改实际代码的情况下更改系统行为。我强烈主张使用功能开关，特别是因为它们允许你的团队为发布代码和发布功能提供单独的流程和时间表。Pete Hodgson在ctohb.com/hodgson上对功能开关有很好的深入解释。

四个关键指标主张尽可能频繁地发布代码。这样做会为你的工程流程的健康带来许多巨大的积极好处。然而，一个自然的担忧是，你的业务可能还没有准备好在代码完成的第二秒让特定功能上线。你的开发和发布时间表可能以这种方式不同步的原因有很多，例如需要与营销激活协调时间、创建客户支持文档、等待监管批准、暂停内部沟通等。功能开关使你的工程团队能够专注于尽可能快速和可靠地发布，并将协调何时启用功能的问题委托给可能由其他团队拥有的带外流程。

### 系统监控：APM和RUM

应用程序性能监控（APM）和真实用户监控（RUM）是两种类型的工具，可帮助团队了解应用程序在生产环境中的表现，并识别或防止面向用户的中断。

APM工具通常位于生产环境中的应用程序内部或旁边，并从后端的角度提供对资源使用情况和请求延迟和吞吐量的分析和洞察。RUM是一个外部工具，假装是用户，并从前端的角度或真实用户的角度提供延迟分析。

如果你必须选择一个（这些工具通常非常昂贵，所以你可能被迫选择其中一个），选择更可能对你的应用程序造成问题的盲点的那个。如果你有大量用户，并且每个小错误或边缘情况都会被实时投诉淹没，那么监控后端负载的APM可能比向你的用户产生冗余警报的RUM更有价值。然而，对于大多数处于种子期或成长期的创业公司，你可能会有不一致的应用程序使用情况，特别是覆盖你的边缘情况，在这种情况下，RUM可能比大部分空闲后端上的APM更有价值。

这个领域的一些常见工具是New Relic、Datadog和Akamai mPulse。

